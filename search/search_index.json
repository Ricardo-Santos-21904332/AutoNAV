{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AutoNAV","text":"<p>A Python package for simulating UAV Navigation in Satellite-Less Environments. The package contains two algorithms the GTRS and WLS whose goal is to estimate and navigate a UAV. Apart from these algorithms a hand-full of other functions and features are also provided, such as, measure the performance using metrics and plot the trajectories.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install from PyPI:</p> <pre><code>pip install --upgrade pip\npip install autonav\n</code></pre>"},{"location":"#first-steps","title":"First Steps","text":"<p>After installing the package one can import the algorithms and necessary dependencies as follows:</p> <pre><code>from autonav import gtrs, wls\nfrom autonav.file_handlers import readpathfile\nfrom autonav.plots import plot_trajectories\nfrom numpy import array\n</code></pre> <p>Afterwards, one can create the necessary values to run the algorithms:</p> <pre><code>b = 200\nn = 8\na_i = array(\n    [\n    [0, 0, 0],\n    [0, b, 0],\n    [b / 2, 0, 0],\n    [b / 2, b, 0],\n    [0, 0, b / 8],\n    [0, b, b / 8],\n    [b / 2, 0, b / 8],\n    [b / 2, b, b / 8],]\n    ).T\nk = 50\nsigma = 1\ninitial_uav_position = [10, 10, 5]\ndestinations = readpathfile(\"tests/path_files/Path.txt\")\n</code></pre> <p>Finally, call the GTRS or WLS algorithm and plot the trajectories:</p> <pre><code>[estimated_trajectory, true_trajectory] = gtrs(a_i, n, k, sigma, destinations, initial_uav_position)\nplot_trajectories(destinations, estimated_trajectory, a_i)\n</code></pre> <p></p>"},{"location":"dev/","title":"For developers","text":"<p>If you wish to add more features to AutoNAV, feel free to install it in developer mode as follows.</p>"},{"location":"dev/#installing-for-development","title":"Installing for development","text":"<p>With the commands below, one will install all the necessary development dependencies.</p> <pre><code>git clone https://github.com/ricardo-s-santos/AutoNAV.git\ncd autonav\npython -m venv env\nsource env/bin/activate\npip install -e .[devel]\npre-commit install\n</code></pre>"},{"location":"dev/#tests","title":"Tests","text":"<p>The AutoNAV package contains several tests to assess its quality. These tests can be runned with the command:</p> <pre><code>pytest\n</code></pre> <p>A coverage report can also be created with the command:</p> <pre><code>pytest --cov=autonav --cov-report=html\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>In this page a few examples of the algorithms in action are provided.</p>"},{"location":"examples/#run-and-plot-the-trajectories-using-the-gtrs-algorithm","title":"Run and plot the trajectories using the GTRS algorithm","text":"<pre><code>from autonav import gtrs\nfrom autonav.file_handlers import readpathfile\nfrom autonav.plots import plot_trajectories\nfrom numpy import array\n</code></pre> <p>Afterwards, one can create the necessary values to run the algorithms:</p> <pre><code>b = 200\nn = 8\na_i = array(\n    [\n    [0, 0, 0],\n    [0, b, 0],\n    [b / 2, 0, 0],\n    [b / 2, b, 0],\n    [0, 0, b / 8],\n    [0, b, b / 8],\n    [b / 2, 0, b / 8],\n    [b / 2, b, b / 8],]\n    ).T\nk = 50\nsigma = 1\ninitial_uav_position = [10, 10, 5]\ndestinations = readpathfile(\"tests/path_files/Path.txt\")\n</code></pre> <p>Finally, call the GTRS algorithm and plot the trajectories:</p> <pre><code>[estimated_trajectory, true_trajectory] = gtrs(a_i, n, k, sigma, destinations, initial_uav_position)\nplot_trajectories(destinations, estimated_trajectory, a_i)\n</code></pre> <p></p>"},{"location":"examples/#run-and-plot-the-trajectories-using-the-wls-algorithm","title":"Run and plot the trajectories using the WLS algorithm","text":"<pre><code>from autonav import wls\nfrom autonav.file_handlers import readpathfile\nfrom autonav.plots import plot_trajectories\nfrom numpy import array\n</code></pre> <p>Afterwards, one can create the necessary values to run the algorithms:</p> <pre><code>b = 200\nn = 8\na_i = array(\n    [\n    [0, 0, 0],\n    [0, b, 0],\n    [b / 2, 0, 0],\n    [b / 2, b, 0],\n    [0, 0, b / 8],\n    [0, b, b / 8],\n    [b / 2, 0, b / 8],\n    [b / 2, b, b / 8],]\n    ).T\nk = 50\nsigma = 1\ninitial_uav_position = [10, 10, 5]\ndestinations = readpathfile(\"tests/path_files/Path.txt\")\n</code></pre> <p>Finally, call the WLS and plot the trajectories:</p> <pre><code>[estimated_trajectory, true_trajectory] = wls(a_i, n, k, sigma, destinations, initial_uav_position)\nplot_trajectories(destinations, estimated_trajectory, a_i)\n</code></pre> <p></p>"},{"location":"examples/#extract-the-rmse-and-armse-from-the-algorithms","title":"Extract the RMSE and ARMSE from the algorithms","text":"<p>To compute the ARMSE and plot the RMSE in each iteration and considering the same settings as in the previous example run:</p> <pre><code>from autonav import wls\nfrom autonav.file_handlers import readpathfile\nfrom autonav.plots import plot_trajectories, plot_rmse\nfrom autonav.metrics import compute_armse\nfrom numpy import array\n</code></pre> <p>Finally, call the WLS and plot the trajectories:</p> <pre><code>[estimated_trajectory, true_trajectory] = wls(a_i, n, k, sigma, destinations, initial_uav_position)\nplot_rmse(true_trajectory, estimated_trajectory)\nprint(f\"Average RMSE: {compute_armse(estimated_trajectory, true_trajectory):0,.2f} (m)\")\n</code></pre> <p></p>"},{"location":"functions/","title":"Available Functions and Documentation","text":"<p>Apart from the algorithms, several auxiliary functions are available. In this page, one can find all the available functions and there respective documentation.</p>"},{"location":"functions/#algorithms","title":"Algorithms","text":""},{"location":"functions/#autonav.gtrs","title":"gtrs","text":"<pre><code>gtrs(\n    a_i: NDArray,\n    n: int,\n    k: int,\n    sigma: float,\n    destinations: NDArray,\n    initial_uav_position: list,\n    noise_seed=0,\n    tol: float = 0.001,\n    n_iter: int = 30,\n    max_lim: float = 1000000.0,\n) -&gt; NDArray\n</code></pre> <p>This function executes the GTRS algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>a_i</code> <code>NDArray</code> <p>The true position of the anchors in 3D.</p> required <code>n</code> <code>int</code> <p>The number of anchors.</p> required <code>k</code> <code>int</code> <p>The number of measurements.</p> required <code>sigma</code> <code>float</code> <p>The noise level in meters.</p> required <code>destinations</code> <code>NDArray</code> <p>The intermediate points need for navigation in 3D.</p> required <code>initial_uav_position</code> <code>list</code> <p>The initial UAV position in 3D.</p> required <code>noise_seed</code> <code>int</code> <p>The seed to generate the noise.</p> <code>0</code> <code>tol</code> <code>float</code> <p>The tolerance for the bisection function.</p> <code>0.001</code> <code>n_iter</code> <code>int</code> <p>The max number of iterations for the bisection function.</p> <code>30</code> <code>max_lim</code> <code>float</code> <p>The maximum value for the interval in the bisection function.</p> <code>1000000.0</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>The estimated trajectory computed using the GTRS algorithm for the given input scenario</p> <code>NDArray</code> <p>and the true trajectory that the UAV followed.</p> Source code in <code>autonav/GTRS.py</code> <pre><code>def gtrs(\n    a_i: NDArray,\n    n: int,\n    k: int,\n    sigma: float,\n    destinations: NDArray,\n    initial_uav_position: list,\n    noise_seed=0,\n    tol: float = 0.001,\n    n_iter: int = 30,\n    max_lim: float = 1000000.0,\n) -&gt; NDArray:\n    \"\"\"This function executes the GTRS algorithm.\n\n    Args:\n        a_i (NDArray): The true position of the anchors in 3D.\n        n (int): The number of anchors.\n        k (int): The number of measurements.\n        sigma (float): The noise level in meters.\n        destinations (NDArray): The intermediate points need for navigation in 3D.\n        initial_uav_position (list): The initial UAV position in 3D.\n        noise_seed (int): The seed to generate the noise.\n        tol (float): The tolerance for the bisection function.\n        n_iter (int): The max number of iterations for the bisection function.\n        max_lim (float): The maximum value for the interval in the bisection function.\n\n    Returns:\n        The estimated trajectory computed using the GTRS algorithm for the given input scenario\n        and the true trajectory that the UAV followed.\n    \"\"\"\n    # Validate inputs\n    if size(a_i, axis=1) != n:\n        raise ValueError(\"The length of a_i must be equal to N.\")\n    if k &lt; 0:\n        raise ValueError(\"K must be positive.\")\n    if sigma &lt; 0 or sigma &gt; 5:\n        raise ValueError(\"Sigma must be between 0 and 5.\")\n    if size(destinations) == 0:\n        raise ValueError(\"Waypoints cannot be empty.\")\n    if size(destinations, axis=1) != 3:\n        raise ValueError(\"Waypoints must contain the 3 coordinates (x, y, z).\")\n    if len(initial_uav_position) != 3:\n        raise ValueError(\"Initial UAV position must contain the 3 coordinates (x, y, z).\")\n    # Test optional inputs\n    if tol &lt; 0:\n        raise ValueError(\"Tolerance must be positive.\")\n    if n_iter &lt; 0:\n        raise ValueError(\"Number of Bisection iterations must be positive.\")\n    if max_lim &lt; 0:\n        raise ValueError(\"The maximum value for the interval in the bisection function must be positive.\")\n    ts = 1  # Time sample in seconds\n    s = eye(6)  # State transition matrix\n    s[0, 3] = ts\n    s[1, 4] = ts\n    s[2, 5] = ts\n    sigma_w = 0.05  # State process noise intensity  # State process noise covariance\n    q = dot(\n        sigma_w**2,\n        (\n            [\n                [ts**3 / 3, 0, 0, ts**2 / 2, 0, 0],\n                [0, ts**3 / 3, 0, 0, ts**2 / 2, 0],\n                [0, 0, ts**3 / 3, 0, 0, ts**2 / 2],\n                [ts**2 / 2, 0, 0, ts, 0, 0],\n                [0, ts**2 / 2, 0, 0, ts, 0],\n                [0, 0, ts**2 / 2, 0, 0, ts],\n            ]\n        ),\n    )\n    x_state = zeros((6, 1))\n    x_loc = zeros((3, 1))\n    p = None\n    qq = 0\n    x_true = initial_uav_position[:]\n    estimated_trajectory = []\n    true_trajectory = []\n    ww = 0\n    n_dest = len(destinations) - 1\n    # Generator to create random numbers (see line 122)\n    gen = randomGenerator(noise_seed)\n    while ww &lt;= n_dest:\n        distance = math.sqrt(\n            (x_true[0] - destinations[ww][0]) ** 2\n            + (x_true[1] - destinations[ww][1]) ** 2\n            + (x_true[2] - destinations[ww][2]) ** 2\n        )\n        while distance &gt; 1:\n            x = x_true[0:3]\n            # ---------------------------------------------------------------------\n            # Simulation part\n            # ---------------------------------------------------------------------\n            di_k = sqrt(((x[0] - a_i[0, :]) ** 2) + ((x[1] - a_i[1, :]) ** 2) + ((x[2] - a_i[2, :]) ** 2))\n            di_k = array([di_k]).T\n            di_k = di_k + (sigma * gen.standard_normal(size=(n, k)))\n            d_i = median(di_k, axis=1)\n            d_i = array([d_i]).T\n            # ---------------------------------------------------------------------\n            # Estimation part\n            # ---------------------------------------------------------------------\n            a1_loc = []\n            b1_loc = []\n            a_track = []\n            d_track = []\n            f_track = []\n            b_track = []\n            w_i_loc = array(sqrt(d_i ** (-1.0) / (sum(d_i ** (-1.0)))))\n            for tt in arange(0, n, 1).reshape(-1):\n                a1_loc.append(append(dot(2, a_i[0:3, tt].T), -1))\n                b1_loc.append(norm(a_i[0:3, tt]) ** 2 - d_i[tt] ** 2)\n            a1_loc = array(a1_loc)\n            b1_loc = array(b1_loc)\n            w_loc = diag(w_i_loc.T[0])\n            d_loc = eye(4)\n            d_loc[3, 3] = 0\n            f_loc = array([0, 0, 0, -1.0 / 2.0]).reshape(4, 1)\n            a_loc = dot(w_loc, a1_loc)\n            b_loc = dot(w_loc, b1_loc)\n            if qq != 0:\n                p_pred = dot(dot(s, p), s.T) + q\n                x_pred = dot(s, x_state[0:6, qq - 1])\n                x_pred = x_pred.reshape(len(x_pred), 1)\n                a1_track = []\n                b1_track = []\n                for tt in arange(0, n, 1).reshape(-1):\n                    a1_track.append(concatenate((dot(2, a_i[0:3, tt].T), zeros(size(x, 0)), [-1]), axis=0))\n                    b1_track.append(norm(a_i[0:3, tt]) ** 2 - abs(d_i[tt] ** 2))\n                a1_track = array(a1_track)\n                b1_track = array(b1_track)\n                left_matrix = sqrtm(inv(p_pred))\n                right_matrix = zeros((size(x_state, 0), 1))\n                a1_track = concatenate((a1_track, concatenate((left_matrix, right_matrix), axis=1)), axis=0)\n                a1_track[a1_track == math.inf] = 0\n                inf_p_pred = array(sqrtm(inv(p_pred)))\n                inf_p_pred[inf_p_pred == math.inf] = 0\n                b1_track = concatenate((b1_track, dot(inf_p_pred, x_pred)), axis=0)\n                a = dot(math.sqrt(1.0 / 2.0), w_i_loc.T)\n                b = dot(math.sqrt(1.0 / 8.0), ones((1, size(x_state, 0))))\n                w_track = concatenate((a, b), axis=1)\n                w_track = eye(size(w_track, 1)) * w_track\n                d_track = zeros((7, 7))\n                d_track[0, 0] = 1\n                d_track[1, 1] = 1\n                d_track[2, 2] = 1\n                f_track = array([0, 0, 0, 0, 0, 0, -1.0 / 2.0]).reshape(7, 1)\n                a_track = dot(w_track, a1_track)\n                b_track = dot(w_track, b1_track)\n            eigen_values = _calc_eigen(a_loc, d_loc)\n            eig_1 = max(eigen_values)\n            min_lim = -1.0 / eig_1\n            lambda_loc = _bisection_fun(min_lim, max_lim, tol, n_iter, a_loc, d_loc, b_loc, f_loc)\n            y_hat_loc = solve(\n                (dot(a_loc.T, a_loc) + dot(lambda_loc, d_loc) + dot(1e-06, eye(size(a_loc, 1)))),\n                (dot(a_loc.T, b_loc) - dot(lambda_loc, f_loc)),\n            )\n            if qq == 0:\n                x_loc[0:3, qq] = real(y_hat_loc[0:3, 0])\n                x_state[0:6, qq] = concatenate((x_loc[0:3, qq], [0], [0], [0]), axis=0)\n                p = eye(6)\n                estimated_trajectory.append(x_loc[0:3, qq])\n            else:\n                x_loc = insert(x_loc, qq, real(y_hat_loc[0:3, 0]), axis=1)\n                eigen_values = _calc_eigen(a_track, d_track)\n                eig_1 = max(eigen_values)\n                min_lim = -1.0 / eig_1\n                lambda_track = _bisection_fun(min_lim, max_lim, tol, n_iter, a_track, d_track, b_track, f_track)\n                y_hat_track = solve(\n                    (dot(a_track.T, a_track) + dot(lambda_track, d_track) + dot(1e-06, eye(size(a_track, 1)))),\n                    (dot(a_track.T, b_track) - dot(lambda_track, f_track)),\n                )\n                x_state = concatenate((x_state, zeros((size(x_state, 0), 1))), axis=1)\n                x_state[0:6, qq] = concatenate((real(y_hat_track[arange(0, size(x_state, 0))])), axis=0)\n                lk1 = subtract(x_state[0:6, qq], x_state[0:6, qq - 1]).reshape((6, 1))\n                lk2 = subtract(x_state[0:6, qq], x_state[0:6, qq - 1]).reshape((6, 1)).T\n                p = matmul(lk1, lk2)\n                estimated_trajectory.append(x_loc[0:3, qq])\n            true_trajectory.append(x_true[:])\n            uav_velocity = _velocity(x_loc[0:3, qq], destinations[ww, :])\n            x_true[0] = x_true[0] + uav_velocity[0]\n            x_true[1] = x_true[1] + uav_velocity[1]\n            x_true[2] = x_true[2] + uav_velocity[2]\n            distance = math.sqrt(\n                (x_true[0] - destinations[ww][0]) ** 2\n                + (x_true[1] - destinations[ww][1]) ** 2\n                + (x_true[2] - destinations[ww][2]) ** 2\n            )\n            qq += 1\n        ww += 1\n    return array([array(estimated_trajectory), array(true_trajectory)])\n</code></pre>"},{"location":"functions/#autonav.wls","title":"wls","text":"<pre><code>wls(\n    a_i: NDArray,\n    n: int,\n    k: int,\n    sigma: float,\n    destinations: NDArray,\n    initial_uav_position: list,\n    noise_seed=0,\n) -&gt; NDArray\n</code></pre> <p>This function executes the WLS algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>a_i</code> <code>NDArray</code> <p>The true position of the anchors in 3D.</p> required <code>n</code> <code>int</code> <p>The number of anchors.</p> required <code>k</code> <code>int</code> <p>The number of measurements.</p> required <code>sigma</code> <code>float</code> <p>The noise level in meters.</p> required <code>destinations</code> <code>NDArray</code> <p>The intermediate points need for navigation in 3D.</p> required <code>initial_uav_position</code> <code>list</code> <p>The initial UAV position in 3D.</p> required <code>noise_seed</code> <code>int</code> <p>The seed to generate the noise.</p> <code>0</code> <p>Returns:</p> Type Description <code>NDArray</code> <p>The estimated trajectory computed using the WLS algorithm for the given input scenario</p> <code>NDArray</code> <p>and the true trajectory that the UAV followed.</p> Source code in <code>autonav/WLS.py</code> <pre><code>def wls(\n    a_i: NDArray, n: int, k: int, sigma: float, destinations: NDArray, initial_uav_position: list, noise_seed=0\n) -&gt; NDArray:\n    \"\"\"This function executes the WLS algorithm.\n\n    Args:\n        a_i (NDArray): The true position of the anchors in 3D.\n        n (int): The number of anchors.\n        k (int): The number of measurements.\n        sigma (float): The noise level in meters.\n        destinations (NDArray): The intermediate points need for navigation in 3D.\n        initial_uav_position (list): The initial UAV position in 3D.\n        noise_seed (int): The seed to generate the noise.\n\n    Returns:\n        The estimated trajectory computed using the WLS algorithm for the given input scenario\n        and the true trajectory that the UAV followed.\n    \"\"\"\n    # Validate inputs\n    if size(a_i, axis=1) != n:\n        raise ValueError(\"The length of a_i must be equal to N.\")\n    if k &lt; 0:\n        raise ValueError(\"K must be positive.\")\n    if sigma &lt; 0 or sigma &gt; 5:\n        raise ValueError(\"Sigma must be between 0 and 5.\")\n    if size(destinations) == 0:\n        raise ValueError(\"Waypoints cannot be empty.\")\n    if size(destinations, axis=1) != 3:\n        raise ValueError(\"Waypoints must contain the 3 coordinates (x, y, z).\")\n    if len(initial_uav_position) != 3:\n        raise ValueError(\"Initial UAV position must contain the 3 coordinates (x, y, z).\")\n    x_true = initial_uav_position[:]\n    ww = 0\n    n_dest = len(destinations) - 1\n    estimated_trajectory = []\n    true_trajectory = []\n    # Generator to create random numbers (see line 65)\n    gen = randomGenerator(noise_seed)\n    while ww &lt;= n_dest:\n        distance = math.sqrt(\n            (x_true[0] - destinations[ww][0]) ** 2\n            + (x_true[1] - destinations[ww][1]) ** 2\n            + (x_true[2] - destinations[ww][2]) ** 2\n        )\n        while distance &gt; 1:\n            x = x_true[0:3]\n            # ---------------------------------------------------------------------\n            # Simulation part\n            # ---------------------------------------------------------------------\n            di_k = sqrt(((x[0] - a_i[0, :]) ** 2) + ((x[1] - a_i[1, :]) ** 2) + ((x[2] - a_i[2, :]) ** 2))\n            di_k = array([di_k]).T\n            di_k = di_k + (sigma * gen.standard_normal(size=(n, k)))\n            d_i = median(di_k, axis=1)\n            d_i = array([d_i]).T\n            # ---------------------------------------------------------------------\n            # Estimation part\n            # ---------------------------------------------------------------------\n            xi_est = []\n            phi_i = []\n            alpha_i = []\n            for ii in range(0, n):\n                a2 = []\n                b2 = []\n                kk = [ii + 1]\n                for jj in range(0, n):\n                    total = 0\n                    if a_i[0, ii] == a_i[0, jj]:\n                        total += 1\n                    if a_i[1, ii] == a_i[1, jj]:\n                        total += 1\n                    if ii != jj and total &gt; 0:\n                        kk.append(jj + 1)\n                for uu in range(0, len(array(list(itertools.combinations(kk, 2))))):\n                    combinations = array(list(itertools.combinations(kk, 2)))\n                    gg = combinations[uu, 0]\n                    hh = combinations[uu, 1]\n                    a2.append(2 * (a_i[0:3, gg - 1] - a_i[0:3, hh - 1]).T)\n                    b2.append(\n                        d_i[hh - 1] ** 2 - d_i[gg - 1] ** 2 - norm(a_i[0:3, hh - 1]) ** 2 + norm(a_i[0:3, gg - 1]) ** 2\n                    )\n                a2 = asarray(a2, dtype=float32)\n                b2 = asarray(b2, dtype=float32)\n                xi_est.append(solve(dot(a2.T, a2) + (1 * 10 ** (-6)) * eye(3), dot(a2.T, b2)))\n                di_xy = norm(xi_est[0][0:2])\n                xi_est[ii][2] = (\n                    cmath.sqrt((d_i[0] ** 2)[0] - (di_xy**2)).real + cmath.sqrt((d_i[0] ** 2)[0] - (di_xy**2)).imag\n                )\n                phi_i.append(\n                    math.atan2((xi_est[ii][1] - a_i[1, ii])[0], (xi_est[ii][0] - a_i[0, ii])[0]) * 180 / math.pi\n                )\n                alpha_i.append(\n                    math.acos((xi_est[ii][2] - a_i[2, ii])[0] / (norm(xi_est[:][ii] - a_i[:, ii].reshape(len(a_i), 1))))\n                    * 180\n                    / math.pi\n                )\n            phi_i = asarray(phi_i, dtype=float32)\n            alpha_i = asarray(alpha_i, dtype=float32)\n            u_i_1 = cos(phi_i * math.pi / 180).T\n            u_i_2 = sin(alpha_i * math.pi / 180).T\n            u_i_3 = sin(phi_i * math.pi / 180).T\n            u_i_4 = cos(alpha_i * math.pi / 180).T\n            u_i = array([[u_i_1 * u_i_2], [u_i_3 * u_i_2], [u_i_4]], dtype=float32).reshape(3, n)\n            a = asarray(u_i.T, dtype=float32)\n            b = d_i + sum(u_i * a_i).T.reshape(n, 1)\n            w_i = asarray((1 / d_i) / (sum(1 / d_i)))\n            w = asarray(eye(n) * scimath.sqrt(w_i))\n            x_est = asarray(solve(dot(dot(a.T, w.T), dot(w, a)), dot(dot(a.T, w.T), dot(w, b))).real)\n            estimated_trajectory.append(x_est[:, 0])\n            true_trajectory.append(x_true[:])\n            uav_velocity = _velocity(x_est[:, 0], destinations[ww, :])\n            x_true[0] = x_true[0] + uav_velocity[0]\n            x_true[1] = x_true[1] + uav_velocity[1]\n            x_true[2] = x_true[2] + uav_velocity[2]\n            distance = math.sqrt(\n                (x_true[0] - destinations[ww][0]) ** 2\n                + (x_true[1] - destinations[ww][1]) ** 2\n                + (x_true[2] - destinations[ww][2]) ** 2\n            )\n        ww += 1\n    return array([array(estimated_trajectory), array(true_trajectory)])\n</code></pre>"},{"location":"functions/#plots","title":"Plots","text":"<p>This module contains the plotting functions.</p>"},{"location":"functions/#autonav.plots.plot_comparison_between_algorithms","title":"plot_comparison_between_algorithms","text":"<pre><code>plot_comparison_between_algorithms(\n    ideal_trajectory: NDArray,\n    estimated_trajectory_GTRS: NDArray,\n    estimated_trajectory_WLS: NDArray,\n    a_i: NDArray,\n) -&gt; None\n</code></pre> <p>This function plots the ideal and estimated trajectory for both algorithms.</p> <p>Parameters:</p> Name Type Description Default <code>ideal_trajectory</code> <code>NDArray</code> <p>The ideal trajectory that the UAV is supposed to follow.</p> required <code>estimated_trajectory_GTRS</code> <code>NDArray</code> <p>The estimated trajectory that the UAV followed using the GTRS algorithm.</p> required <code>estimated_trajectory_WLS</code> <code>NDArray</code> <p>The estimated trajectory that the UAV followed using the WLS algorithm.</p> required <code>a_i</code> <code>NDArray</code> <p>The position of the anchors.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Nothing.</p> Source code in <code>autonav/plots.py</code> <pre><code>def plot_comparison_between_algorithms(\n    ideal_trajectory: NDArray, estimated_trajectory_GTRS: NDArray, estimated_trajectory_WLS: NDArray, a_i: NDArray\n) -&gt; None:\n    \"\"\"This function plots the ideal and estimated trajectory for both algorithms.\n\n    Args:\n        ideal_trajectory: The ideal trajectory that the UAV is supposed to follow.\n        estimated_trajectory_GTRS: The estimated trajectory that the UAV followed using the GTRS algorithm.\n        estimated_trajectory_WLS: The estimated trajectory that the UAV followed using the WLS algorithm.\n        a_i: The position of the anchors.\n\n    Returns:\n        Nothing.\n    \"\"\"\n    ax = plt.axes(projection=\"3d\")\n    a_i_label = \"a_i\"\n    for i in range(0, a_i.shape[1]):\n        ax.plot3D(\n            a_i[0][i],\n            a_i[1][i],\n            a_i[2][i],\n            marker=\"s\",\n            markersize=10,\n            markeredgecolor=\"black\",\n            markerfacecolor=\"black\",\n            label=a_i_label,\n        )\n        a_i_label = \"_nolegend_\"  # Legend only in the first iteration\n    ax.plot3D(\n        ideal_trajectory[:, 0],\n        ideal_trajectory[:, 1],\n        ideal_trajectory[:, 2],\n        color=\"green\",\n        label=\"Ideal Trajectory\",\n        linewidth=3.0,\n        alpha=0.7,\n    )\n    ax.plot3D(\n        estimated_trajectory_GTRS[:, 0],\n        estimated_trajectory_GTRS[:, 1],\n        estimated_trajectory_GTRS[:, 2],\n        color=\"red\",\n        label=\"Estimated Trajectory GTRS\",\n        alpha=1.0,\n    )\n    ax.plot3D(\n        estimated_trajectory_WLS[:, 0],\n        estimated_trajectory_WLS[:, 1],\n        estimated_trajectory_WLS[:, 2],\n        color=\"blue\",\n        label=\"Estimated Trajectory WLS\",\n        alpha=1.0,\n    )\n    plt.xlabel(\"Width\")\n    plt.ylabel(\"Length\")\n    plt.legend()\n    plt.show()\n</code></pre>"},{"location":"functions/#autonav.plots.plot_rmse","title":"plot_rmse","text":"<pre><code>plot_rmse(true_trajectory: NDArray, estimated_trajectory: NDArray) -&gt; None\n</code></pre> <p>This function plots the root mean squared error along the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>true_trajectory</code> <code>NDArray</code> <p>The true trajectory that the UAV followed.</p> required <code>estimated_trajectory</code> <code>NDArray</code> <p>The estimated trajectory.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Nothing.</p> Source code in <code>autonav/plots.py</code> <pre><code>def plot_rmse(true_trajectory: NDArray, estimated_trajectory: NDArray) -&gt; None:\n    \"\"\"This function plots the root mean squared error along the trajectory.\n\n    Args:\n        true_trajectory: The true trajectory that the UAV followed.\n        estimated_trajectory: The estimated trajectory.\n\n    Returns:\n        Nothing.\n    \"\"\"\n    rmse = compute_rmse(estimated_trajectory, true_trajectory)\n    plt.plot(rmse, label=\"RMSE\")\n    plt.xlabel(\"Iteration\")\n    plt.ylabel(\"RMSE (m)\")\n    plt.legend()\n    plt.show()\n</code></pre>"},{"location":"functions/#autonav.plots.plot_rmse_comparison_between_algorithms","title":"plot_rmse_comparison_between_algorithms","text":"<pre><code>plot_rmse_comparison_between_algorithms(\n    true_trajectory_GTRS: NDArray,\n    estimated_trajectory_GTRS: NDArray,\n    true_trajectory_WLS: NDArray,\n    estimated_trajectory_WLS: NDArray,\n) -&gt; None\n</code></pre> <p>This function plots the root mean squared error along the trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>true_trajectory_GTRS</code> <code>NDArray</code> <p>The true trajectory that the UAV followed using the GTRS algorithm.</p> required <code>estimated_trajectory_GTRS</code> <code>NDArray</code> <p>The estimated trajectory by the GTRS algorithm.</p> required <code>true_trajectory_WLS</code> <code>NDArray</code> <p>The true trajectory that the UAV followed using the WLS algorithm.</p> required <code>estimated_trajectory_WLS</code> <code>NDArray</code> <p>The estimated trajectory by the WLS algorithm.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Nothing.</p> Source code in <code>autonav/plots.py</code> <pre><code>def plot_rmse_comparison_between_algorithms(\n    true_trajectory_GTRS: NDArray,\n    estimated_trajectory_GTRS: NDArray,\n    true_trajectory_WLS: NDArray,\n    estimated_trajectory_WLS: NDArray,\n) -&gt; None:\n    \"\"\"This function plots the root mean squared error along the trajectory.\n\n    Args:\n        true_trajectory_GTRS: The true trajectory that the UAV followed using the GTRS algorithm.\n        estimated_trajectory_GTRS: The estimated trajectory by the GTRS algorithm.\n        true_trajectory_WLS: The true trajectory that the UAV followed using the WLS algorithm.\n        estimated_trajectory_WLS: The estimated trajectory by the WLS algorithm.\n\n    Returns:\n        Nothing.\n    \"\"\"\n    rmse_GTRS = compute_rmse(estimated_trajectory_GTRS, true_trajectory_GTRS)\n    rmse_WLS = compute_rmse(estimated_trajectory_WLS, true_trajectory_WLS)\n    plt.plot(rmse_GTRS, label=\"RMSE GTRS\")\n    plt.plot(rmse_WLS, label=\"RMSE WLS\")\n    plt.xlabel(\"Iteration\")\n    plt.ylabel(\"RMSE (m)\")\n    plt.legend()\n    plt.show()\n</code></pre>"},{"location":"functions/#autonav.plots.plot_trajectories","title":"plot_trajectories","text":"<pre><code>plot_trajectories(\n    ideal_trajectory: NDArray, estimated_trajectory: NDArray, a_i: NDArray\n) -&gt; None\n</code></pre> <p>This function plots the ideal and estimated trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>ideal_trajectory</code> <code>NDArray</code> <p>The ideal trajectory that the UAV is supposed to follow.</p> required <code>estimated_trajectory</code> <code>NDArray</code> <p>The estimated trajectory that the UAV followed.</p> required <code>a_i</code> <code>NDArray</code> <p>The position of the anchors.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Nothing.</p> Source code in <code>autonav/plots.py</code> <pre><code>def plot_trajectories(ideal_trajectory: NDArray, estimated_trajectory: NDArray, a_i: NDArray) -&gt; None:\n    \"\"\"This function plots the ideal and estimated trajectory.\n\n    Args:\n        ideal_trajectory: The ideal trajectory that the UAV is supposed to follow.\n        estimated_trajectory: The estimated trajectory that the UAV followed.\n        a_i: The position of the anchors.\n\n    Returns:\n        Nothing.\n    \"\"\"\n    ax = plt.axes(projection=\"3d\")\n    a_i_label = \"a_i\"\n    for i in range(0, a_i.shape[1]):\n        ax.plot3D(\n            a_i[0][i],\n            a_i[1][i],\n            a_i[2][i],\n            marker=\"s\",\n            markersize=10,\n            markeredgecolor=\"black\",\n            markerfacecolor=\"black\",\n            label=a_i_label,\n        )\n        a_i_label = \"_nolegend_\"  # Legend only in the first iteration\n    ax.plot3D(\n        ideal_trajectory[:, 0],\n        ideal_trajectory[:, 1],\n        ideal_trajectory[:, 2],\n        color=\"green\",\n        label=\"Ideal Trajectory\",\n        linewidth=3.0,\n        alpha=0.7,\n    )\n    ax.plot3D(\n        estimated_trajectory[:, 0],\n        estimated_trajectory[:, 1],\n        estimated_trajectory[:, 2],\n        color=\"red\",\n        label=\"Estimated Trajectory\",\n        alpha=1.0,\n    )\n    plt.xlabel(\"Width\")\n    plt.ylabel(\"Length\")\n    plt.legend()\n    plt.show()\n</code></pre>"},{"location":"functions/#metrics","title":"Metrics","text":"<p>This module contains the metrics functions.</p>"},{"location":"functions/#autonav.metrics.compute_armse","title":"compute_armse","text":"<pre><code>compute_armse(estimated_trajectory: NDArray, true_trajectory: NDArray) -&gt; float\n</code></pre> <p>This function computes the average root mean squared error between the true and estimated trajectory of the UAV.</p> <p>Parameters:</p> Name Type Description Default <code>estimated_trajectory</code> <code>NDArray</code> <p>The estimated position of the UAV.</p> required <code>true_trajectory</code> <code>NDArray</code> <p>The true position of the UAV.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The average root mean squared error between the true and the estimated positions of the UAV.</p> Source code in <code>autonav/metrics.py</code> <pre><code>def compute_armse(estimated_trajectory: NDArray, true_trajectory: NDArray) -&gt; float:\n    \"\"\"This function computes the average root mean squared error between the true and estimated trajectory of the UAV.\n\n    Args:\n        estimated_trajectory: The estimated position of the UAV.\n        true_trajectory: The true position of the UAV.\n\n    Returns:\n        The average root mean squared error between the true and the estimated positions of the UAV.\n    \"\"\"\n    rmse = compute_rmse(estimated_trajectory, true_trajectory)\n    if len(rmse) != 0:\n        armse = sum(rmse) / len(rmse)\n    else:\n        raise ZeroDivisionError(\"RMSE is empty!\")\n    return armse\n</code></pre>"},{"location":"functions/#autonav.metrics.compute_rmse","title":"compute_rmse","text":"<pre><code>compute_rmse(estimated_trajectory: NDArray, true_trajectory: NDArray) -&gt; list\n</code></pre> <p>This function computes the root mean squared error between the true and estimated trajectory of the UAV.</p> <p>Parameters:</p> Name Type Description Default <code>estimated_trajectory</code> <code>NDArray</code> <p>The estimated position of the UAV.</p> required <code>true_trajectory</code> <code>NDArray</code> <p>The true position of the UAV.</p> required <p>Returns:</p> Type Description <code>list</code> <p>The average root mean squared error between the true and the estimated positions of the UAV.</p> Source code in <code>autonav/metrics.py</code> <pre><code>def compute_rmse(estimated_trajectory: NDArray, true_trajectory: NDArray) -&gt; list:\n    \"\"\"This function computes the root mean squared error between the true and estimated trajectory of the UAV.\n\n    Args:\n        estimated_trajectory: The estimated position of the UAV.\n        true_trajectory: The true position of the UAV.\n\n    Returns:\n        The average root mean squared error between the true and the estimated positions of the UAV.\n    \"\"\"\n    rmse = []\n    # Trajectories must have the same length for comparison\n    if len(estimated_trajectory) == len(true_trajectory):\n        for i in range(len(estimated_trajectory)):\n            norm = sqrt(\n                (true_trajectory[i][0] - estimated_trajectory[i][0]) ** 2\n                + (true_trajectory[i][1] - estimated_trajectory[i][1]) ** 2\n                + (true_trajectory[i][2] - estimated_trajectory[i][2]) ** 2\n            )\n            rmse.append(sqrt(norm))\n    return rmse\n</code></pre>"},{"location":"functions/#other-functions","title":"Other functions","text":"<p>This module contains the functions to read the Path.txt file.</p>"},{"location":"functions/#autonav.file_handlers.readpathfile","title":"readpathfile","text":"<pre><code>readpathfile(filename: str) -&gt; NDArray\n</code></pre> <p>This function reads the Path file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to read.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>The waypoints needed to guide the drone.</p> Source code in <code>autonav/file_handlers.py</code> <pre><code>def readpathfile(filename: str) -&gt; NDArray:\n    \"\"\"This function reads the Path file.\n\n    Args:\n        filename: The name of the file to read.\n\n    Returns:\n        The waypoints needed to guide the drone.\n    \"\"\"\n    positions = []\n    if os.path.isfile(filename):  # See if file exists\n        with open(filename, \"r\") as file:\n            csv_file = csv.reader(file)\n            for line in csv_file:\n                positions.append([float(x) for x in line])\n    else:\n        raise FileNotFoundError(\"File not found, please check path.\") from None\n    return array(positions)\n</code></pre>"}]}